### debug.acd ########################################################
#
# Adventure770 -- Copyleft Mike Arnautov 2010-2020.
#
# This optional adv770 module can be included in the adv770.acd file
# anywhere between procs.acd and actions.acd -- placing it anywhere
# else may cause problems. The resulting executable will be marginally
# larger and will include wiz (or debug) mode commands. These can
# be listed using the standard VOCABULARY command. Use WIZARD ON
# and WIZARD OFF to activate or deactivate the wiz mode. As a safety
# precaution, the default state is OFF.
#
# WARNING: if built with the debug.acd module, the game will be able
# to load save files generated by executables built without the module,
# but not the other way around.
#
#=====================================================================
#
# Commands exclusive to the wiz mode
#
verb increment
verb decrement
verb next
verb previous
verb numbers
verb !runout
verb notbeen
verb dotest
verb dumpdata
#
#=====================================================================
#
var entname
var magick
var lastloc
flags variable
    nowiz
    glowing
    show.numbers
#
#=====================================================================
#
text YOU.GLOW
    [Your body is surrounded by a magical glow./The glow surrounding
    your body fades out.]

#
fragment cycle YOUR.MAGNIFICENCE
    Your [Mightiness/Wizardness/Magnificence/Puissance/Splendiferousness]
#
text STATE.IS.NOW
   The state of the object '{arg2}' is now $. The description now reads:
#
text NO.CAN.SET
    But, {YOUR.MAGNIFICENCE}! The state of the object '{arg2}'
    would become negative: $!
#
text VOCAB.WIZ
    Wizard (i.e. debug) commands:

   /   close cave                   - triggers the next cave closure stage
   /   decrement \<entity\>           - decrement state value of object or location 
   /   dumpdata \[\{obj|loc|var|text\}\]     - show entity details
   /   fetch \<object\> (obtain)      - fetch the object from wherever
   /   find \<object\>                - go where the object is
   /   fly \<location\> (teleport)    - go to the named location
   /   glow                         - toggle magical illumination
   /   increment \<entity\>           - increment state value of object or location 
   /   mutter                       - try for the next orc mutter
   /   next                         - go to the next higher location
   /   notbeen                      - show locations not yet visited
   /   previous                     - go to the next lower location
   /   runout                       - sets event clock to zero
   /   \[show\] numbers               - toggles loc number repeated display
   /   show \<entity\>                - Displays entity's current value
   /   thurb                        - in ice maze, go to ice maze exit
   /   where                        - shows where one is (and came from)
   /   where treasure               - shows valued objects (sorted on seen flag)
   /   where water                  - shows water-holes
   /   where \<object\>               - shows object's location
   /   wizard \{on|off}              - switches wizard mode on or off
#
fragment random YOUR.WISH
    [To hear is to obey/Your wish is my command/As you desire/
    It shall be so/Of course. Immediately]
#
text random TO.HEAR.IS.TO.OBEY
    {YOUR.WISH},[/ Oh/=] [{YOUR.MAGNIFICENCE}/Great Wizard/Mighty One/
    the Greatest of Wizards]!

#
text increment NO.DESTINATION
    Assuredly {YOUR.MAGNIFICENCE} can {ARG1}, but alas, a destination is
    required.
#
text WIZ.NO.CHANGE
    But, {YOUR.MAGNIFICENCE}!.. The wizard mode is *already* {ARG2}!
#
text WIZ.NOT.OBJECT
    Alas, {YOUR.MAGNIFICENCE}, {ARG2} is not actually 
    a[n/ portable] object.
#
text cycle BAD.WIZ.COM
    I am [mortified/ashamed/disturbed/perplexed] to find
    myself [not understanding/uncomprehending].
#
text .NAMED.VALUE
    The value of # is $.
#
fragment assigned ENT.TYPE
    [Object/Location/Variable]
#
#=====================================================================
#
proc is.it.dark?
   ifflag magick, nowiz
      proceed
   fin
   ifflag magick, glowing
      flag status, light.here
      return
   fin
#
#---------------------------------------------------------------------
#
proc change.state, delta
   local state
#
   ifflag magick, nowiz
      proceed
   fin
   ifeq status, 1
      flag status, pls.clarify
      quip could.you.clarify?
   fin
   ifflag arg2, object
      or
   ifflag arg2, place
      eval state, arg2
      add state, delta
      ifge state, 0
         deposit arg2, state
         say state.is.now, state
         quip arg2
      fin
      quip no.can.set, state
   fin
   quip hah!
#
#---------------------------------------------------------------------
#
proc place.chain, step
   ifflag magick, nowiz
      proceed
   fin
   ifnear starstone, iridescent
      set starstone, darkened
   fin
   ifeq step 1
     and
   ifat ylem
      move road
   otherwise
   ifeq step, -1
      and
   ifat road
      move ylem
   else
      set place.ptr, here
      add place.ptr, step
      move place.ptr
   fin
   quit
#
#---------------------------------------------------------------------
#
proc dotest.proc
#
# Ad hoc code for various ad hoc tests. Modify as appropriate.
#
# Swag dropping test.
#
#   flag dwarf, seen
#   flag axe, seen
#   apport axe, inhand
#   set dwarf, 1
#   apport dwarf, here
#   apport crucifix, storeroom
#   lda swag.to.drop, crucifix
#   quit
#
# Dim lamp test.
#
    set lamplife, 42
#
    say ok!
#
#---------------------------------------------------------------------
#
proc show.where, msg, entity, end
  say msg
  set entname, entity
  say "f: '{ENTNAME}' (refno $)", entname
  ifeq end, 1
    say "."
  otherwise
  ifeq end, 2
    say blank
  fin
#
#---------------------------------------------------------------------
#
proc wiz.reports
   ifflag magick, nowiz
      proceed
   fin
   ifflag magick, show.numbers
      and
   ifne lastloc, here
      set lastloc, here
      say blank
      call show.where "f:I beg to report that this be_", here, 1
   fin
#
#======================================================================
#
action close cave
   ifflag magick, nowiz
      proceed
   fin
   ifflag here, not.in.cave,
      and
   ifle stage, adventuring
      goto y2
      flag status, moved
   fin
   say to.hear.is.to.obey, 0
   ifeq stage, adventuring
      flag tusk, valued
      flag rug, valued
      itobj obj.ptr, valued
         flag obj.ptr, seen
         apport obj.ptr, house
      fin
      apport starstone, stupendous.view
      set stage, closing.soon
   otherwise
   ifeq stage, closing.soon
      call closing.time
   otherwise
   ifeq stage, exits.barred
      call close.the.cave
   otherwise
   ifeq stage, in.repository
      call mirror.jump
   otherwise
   ifeq stage, middle.of.nowhere
      call lets.go.back
   else
      quip nothing
   fin
   quit
#
#---------------------------------------------------------------------
#
action find
   ifflag magick, nowiz
      proceed
   fin
   ifflag arg2, place
      call fly
   fin
   ifflag arg2, object
      ifhave arg2
         quip you.have.it, arg2
      fin
      ifat arg2
         quip you.are.there
      fin
      locate place.ptr, arg2
      ifgt place.ptr, 0
         move place.ptr
      else
         quip, "Oddly, {ARG2} is nowhere to be found!"
      fin
   else
      quip wiz.not.object, 0
   fin
#
#---------------------------------------------------------------------
#
action runout
   ifflag magick, nowiz
      proceed
   fin
   set clock, 0
   say to.hear.is.to.obey
   smove here, ok!
#
#---------------------------------------------------------------------
#
action glow
   ifflag magick, nowiz
      proceed
   fin
   ifflag magick, glowing
      unflag magick, glowing
      say you.glow, 1
      call is.it.dark?
      ifflag status, light.here
         ifat plain.2
            call phog
            quip glow
         fin
      else
         call too.dark.for.safety, 1
      fin
   else      
      flag magick, glowing
      say you.glow, 0
      set glow, 0
      ifflag status, light.here
      else
         flag status, light.here
         ifnear owl
            call owl.flies.off
         fin
         call describe.here, default
      fin
   fin
   quit
#
#---------------------------------------------------------------------
#
action fetch
   ifflag magick, nowiz
      proceed
   fin
   ifeq status, 1
      flag status, pls.clarify
      quip could.you.clarify?
   fin
   ifeq status, 2
      ifflag arg2, object
         and
      ifflag arg2, portable
         get arg2
         flag arg2, seen
         ifflag arg2, unstable
            call unstable.pick.up
         fin
         quip you.do.it
      fin
   fin   
   quip wiz.not.object, 1
#
#---------------------------------------------------------------------
#
action mutter
   ifflag magick, nowiz
      proceed
   fin
   set mutter.time, 0
   quip to.hear.is.to.obey
#
#---------------------------------------------------------------------
#
action numbers
   ifflag magick, nowiz
      proceed
   fin
   ifflag magick, show.numbers
      unflag magick, show.numbers
   else
      flag magick, show.numbers
   fin
   flag status, moved
   quip to.hear.is.to.obey
#
#---------------------------------------------------------------------
#
action dumpdata
   ifflag magick, nowiz
      proceed
   fin
   dumpdata   # No need for AGR2!
   quit
#
#---------------------------------------------------------------------
#
action increment
   call change.state, 1
#
#---------------------------------------------------------------------
#
action decrement
   call change.state, -1
#
#---------------------------------------------------------------------
#
action thurb
   ifflag magick, nowiz
      proceed
   fin
   ifat ice.cave.30
   else
      smove ice.cave.30, foof.random
   fin
#
#---------------------------------------------------------------------
#
action vocabulary
   ifflag magick, nowiz
      proceed
   fin
   ifkey wizard
      quip vocab.wiz
   fin       
   ifeq status, 1
      or
   ifkey all
      say vocab.wiz
      set context, q.vocab.0
      quip more?
   fin
#
#---------------------------------------------------------------------
#
action fly
   ifflag magick, nowiz
      proceed
   fin
   ifeq status, 1
      quip no.destination
   fin
   ifkey catacombs
      lda arg2, catacombs.lobby
   fin
   ifflag arg2, place
      flag arg2, been.here
      smove fly, arg2, foof.random
   else
      quip bad.wiz.com
   fin
#
#---------------------------------------------------------------------
#
action next
   call place.chain, 1
#
#---------------------------------------------------------------------
#
action previous
   call place.chain, -1
#
#---------------------------------------------------------------------
#
proc on.off, wanted.state
   local glow.state
   ifkey wizard
      call wizard
   fin
   ifnear lamp
      proceed
   fin
   ifflag magick, glowing
      set glow.state, 1
   fin
   ifne glow.state, wanted.state
      call glow
      quit
   fin
#
#---------------------------------------------------------------------
#
action on
   call on.off, 1
#
#---------------------------------------------------------------------
#
action off
   call on.off, 0
#
#---------------------------------------------------------------------
#
action wizard
   ifkey off
      ifflag magick, nowiz
         quip wiz.no.change
      fin
      flag magick, nowiz
      quip to.hear.is.to.obey
   fin
   ifkey on
      ifflag magick, nowiz
         unflag magick, nowiz
         quip to.hear.is.to.obey
      fin
      quip wiz.no.change
   fin
#
#---------------------------------------------------------------------
#
action where
  local tmp
  ifflag magick, nowiz
     proceed
  fin
  ifeq status, 1
    ifeq there, 0
      or
    ifeq there, here
      set tmp, 1
    fin
    call show.where, "f:{YOUR.MAGNIFICENCE} is at ", here, tmp
    ifeq tmp, 0
      call show.where, "f:, having arrived here from ", there, 1
    fin
  else
    ifkey treasure
      say "I beg to report that the following items are currently of value:
         /Not yet seen:"
      itobj obj.ptr, valued
        ifflag, obj.ptr, seen
          add tmp, 1
        else
          locate temp.ptr, obj.ptr
          set entname, obj.ptr
          call show.where, "f:___{ENTNAME} at ", temp.ptr, 2
        fin
      fin
      say "Already seen:[ none/]", tmp
      itobj obj.ptr, valued
        ifflag, obj.ptr, seen
          locate temp.ptr, obj.ptr
          set entname, obj.ptr
          call show.where, "f:___{ENTNAME} at ", temp.ptr, 2
        fin
      fin
    otherwise
    ifflag arg2, object
      locate temp.ptr, arg2
      call show.where, "f:Be advised that the object '{ARG2}' is at ", temp.ptr, 1
      ifkey water
        say "Personal supply of water can be replenished at:"
        itplace place.ptr
          ifflag place.ptr, h20.here
            call show.where, "f:___", place.ptr, 2
          fin
        fin
      fin
    else
      quip wiz.not.object, 0
    fin
  fin
  quit
#
#---------------------------------------------------------------------
#
action notbeen
  ifflag magick, nowiz
    proceed
  fin
  itplace place.ptr
    ifflag place.ptr, been.here
    else
      set entname, place.ptr
      say "{ENTNAME} not yet visited"
    fin
  fin
  quit
#
#---------------------------------------------------------------------
#
action show
   local tmp
   ifkey numbers
     call arg2
   fin
   ifflag arg2, object
     set ent.type, 0
   otherwise
   ifflag arg2, place
     set ent.type, 1
   else
     set ent.type, 2
  fin   
  eval tmp, arg2
  say "f:{ENT.TYPE} {ARG2} has the value $ and flags ", tmp
  iterate tmp, 0, 15
    ifflag arg2, tmp
      say "f:1"
    else
      say "f:0"
    fin
  fin
  quip "."
#
#---------------------------------------------------------------------
#
action dotest
   call dotest.proc
   return
#
#=====================================================================
#
at nowhere
   ifflag magick, nowiz
      proceed
   fin
   ifgt stage, little.joke
      and
   ifkey basingstoke
      and
   ifeq escape, 0
      set escape, -1   
   fin
#
#=====================================================================
#
init
   local tmp
   randomise your.magnificence, 0
   flag magick, nowiz
   set tmp, 52
   exec 22, tmp     # I have a big screen! :-)
#
#####################################################################
